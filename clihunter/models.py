# clihunter/models.py
import time
import uuid
from typing import List, Optional, Union, Any # Any 可能不再需要
from pydantic import BaseModel, Field, field_validator

class CommandEntry(BaseModel):
    """
    Represents a command record stored in the database.
    (MVP version, embedding-related fields removed)
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    
    raw_command: str = Field(..., description="Original command read from history or manually added by user")
    
    processed_command: Optional[str] = Field(None, description="Command generated by LLM from description to enhance sparse retrieval")
    
    description: Optional[str] = Field(None, description="Command description generated by LLM or provided by user")
    
    tags: List[str] = Field(default_factory=list, description="Tags suggested by user or LLM")
    
    source: Optional[str] = Field(None, description="Command source (e.g., 'bash_history', 'zsh_history', 'manual')")
    history_timestamp: Optional[int] = Field(None, description="Original timestamp parsed from history file (Unix timestamp)")
    added_timestamp: int = Field(default_factory=lambda: int(time.time()), description="Timestamp when command was added to this tool's database (Unix timestamp)")

    which_info: Optional[str] = Field(None, description="Output of 'which <command>'")
    help_info: Optional[str] = Field(None, description="Output of '<command> --help' (or similar), truncated")
    man_info: Optional[str] = Field(None, description="Output of 'man <command> | col -bx', truncated")

    # natural_query_alias: Optional[str] = Field(None, description="LLM-generated alias for the command")

    class Config:
        validate_assignment = True 

    @field_validator('raw_command')
    def raw_command_must_not_be_empty(cls, value):
        if not value.strip():
            raise ValueError('Raw command cannot be empty')
        return value

    def get_searchable_text(self) -> str:
        """
        Get combined text for FTS5 sparse retrieval.
        Now processed_command is the command generated by LLM from description.
        """
        parts = []
        if self.raw_command: # Original command is always included
            parts.append(self.raw_command)
        if self.processed_command and self.processed_command != self.raw_command: # If LLM-generated command differs from original, also include it
            parts.append(self.processed_command)
        if self.description:
            parts.append(self.description)
        if self.tags:
            parts.append(" ".join(self.tags)) 

        if self.which_info and not "N/A" in self.which_info.lower():
            parts.append(self.which_info)
        if self.help_info and not "N/A" in self.help_info.lower():
            parts.append(self.help_info)
        if self.man_info and not "N/A" in self.help_info.lower():
            parts.append(self.man_info)
            
        return " ".join(filter(None, parts))


if __name__ == "__main__":
    cmd_data_full_context = {
        "raw_command": "grep -ril 'TODO' ./src",
        "processed_command": "grep recursive case-insensitive list-files 'TODO' in ./src",
        "description": "Recursively search for 'TODO' in files within ./src, case-insensitive, listing filenames.",
        "tags": ["search", "grep", "todo"],
        "source": "test_manual",
        "which_info": "/usr/bin/grep",
        "help_info": "Usage: grep [OPTION]... PATTERNS [FILE]...\nSearch for PATTERNS in each FILE.\n... (help output truncated)",
        "man_info": "GREP(1) User Commands GREP(1)\nNAME\n grep, egrep, fgrep, rgrep - print lines matching a pattern\n... (man output truncated)"
    }
    entry_with_context = CommandEntry(**cmd_data_full_context)
    print("CommandEntry with Context:")
    print(entry_with_context.model_dump_json(indent=2)) # Pydantic V2
    
    print(f"\nSearchable text (with context):\n{entry_with_context.get_searchable_text()[:500]}...")

    cmd_data_no_context = {
        "raw_command": "my_alias arg",
        "description": "Runs my custom alias with an argument.",
        "which_info": "N/A", 
        "help_info": "Error: my_alias --help timed out.", 
        "man_info": None 
    }
    entry_no_context = CommandEntry(**cmd_data_no_context)
    print("\nCommandEntry with problematic/missing context:")
    print(entry_no_context.model_dump_json(indent=2))
    print(f"\nSearchable text (problematic context):\n{entry_no_context.get_searchable_text()}")
